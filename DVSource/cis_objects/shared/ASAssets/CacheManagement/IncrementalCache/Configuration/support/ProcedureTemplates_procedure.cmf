<?xml version="1.1" encoding="UTF-8"?>
<metadata name="ProcedureTemplates" path="/shared/ASAssets/CacheManagement/IncrementalCache/Configuration/support/ProcedureTemplates" type="PROCEDURE" subtype="SQL_SCRIPT_PROCEDURE" changeToken="0">
  <annotation>Contains the templates for all the automatically generated views and procedures.

    Items in the templates that need to be substituted with configured text are tagged
    with a &lt;DEF_...&gt;
    
    Modified Date:	Modified By:		CSW Version:	Reason:
    09/15/2010		Calvin Goodrich 	5.2.0			Created new
    03/12/2013      Calvin Goodrich     6.2.1           Updated to take advantage of new incremental caching framework in 6.2.1
    04/14/2014      Calvin Goodrich     6.2.6           Began updates to include support for MySQL and Microsoft SQL Server cache data sources (NOT FULLY IMPLEMENTED.)

    © 2010, 2014 Cisco and/or its affiliates. All rights reserved.</annotation>
  <parameters></parameters>
  <security>
    <owner user="admin" domain="composite"/>
  </security>
  <dependency target="/lib/util/System" type="DEFINITION_SET">
    <datatype name="Tree" type="TREE" refId="1"></datatype>
  </dependency>
  <attribute name="Script" type="STRING">/*
    Contains the templates for all the automatically generated views and procedures.

    Items in the templates that need to be substituted with configured text are tagged
    with a &lt;DEF_...&gt;
    
    Modified Date:	Modified By:		CSW Version:	Reason:
    09/15/2010		Calvin Goodrich 	5.2.0			Created new
    03/12/2013      Calvin Goodrich     6.2.1           Updated to take advantage of new incremental caching framework in 6.2.1
    04/14/2014      Calvin Goodrich     6.2.6           Began updates to include support for MySQL and Microsoft SQL Server cache data sources (NOT FULLY IMPLEMENTED.)

    © 2010, 2014 Cisco and/or its affiliates. All rights reserved.
*/
PROCEDURE ProcedureTemplates()
BEGIN
    DECLARE PUBLIC PART_CACHED_VIEW_TEMPLATE CONSTANT System.Text DEFAULT
&apos;-- Automatically generated with &lt;DEF_PROC&gt; 
-- by &lt;DEF_USERID&gt; 
-- on &lt;DEF_CURRENT_TIMESTAMP&gt;
--
SELECT
&lt;DEF_SELECT_ALL_COLS&gt;
FROM      
    &lt;DEF_ORIG_VIEW_PATH&gt;
WHERE
    &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &gt;= DATE &apos;&apos;&lt;DEF_PARTITION_DATE&gt;&apos;&apos;
&apos;;
 
    DECLARE PUBLIC PART_LIVE_VIEW_TEMPLATE CONSTANT System.Text DEFAULT
&apos;-- Automatically generated with &lt;DEF_PROC&gt; 
-- by &lt;DEF_USERID&gt; 
-- on &lt;DEF_CURRENT_TIMESTAMP&gt;
--
SELECT
&lt;DEF_SELECT_ALL_COLS&gt;
FROM      
    &lt;DEF_ORIG_VIEW_PATH&gt;
WHERE
    &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &lt; DATE &apos;&apos;&lt;DEF_PARTITION_DATE&gt;&apos;&apos;
&apos;;
 
    DECLARE PUBLIC PART_UNION_VIEW_TEMPLATE CONSTANT System.Text DEFAULT
&apos;-- Automatically generated with &lt;DEF_PROC&gt; 
-- by &lt;DEF_USERID&gt; 
-- on &lt;DEF_CURRENT_TIMESTAMP&gt;
--
-- Original code copied to &lt;DEF_ORIG_VIEW_PATH&gt;
--
SELECT
&lt;DEF_SELECT_ALL_COLS&gt;
    --,CAST(&apos;&apos;cache&apos;&apos; AS VARCHAR(5)) AS SOURCE -- uncomment to add column indicating which partition the data came from
FROM      
    &lt;DEF_CACHED_VIEW_PATH&gt;
WHERE
    &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &gt;= DATE &apos;&apos;&lt;DEF_PARTITION_DATE&gt;&apos;&apos;
 
UNION ALL {OPTION ROUND_ROBIN}
 
SELECT
&lt;DEF_SELECT_ALL_COLS&gt;
    --,CAST(&apos;&apos;live&apos;&apos; AS VARCHAR(5)) AS SOURCE -- uncomment to add column indicating which partition the data came from
FROM      
    &lt;DEF_LIVE_VIEW_PATH&gt;
WHERE
    &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &lt; DATE &apos;&apos;&lt;DEF_PARTITION_DATE&gt;&apos;&apos;
&apos;;
 
    DECLARE PUBLIC DEFINITIONS_TEMPLATE CONSTANT System.Text DEFAULT
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
*/
PROCEDURE Definitions(
    OUT result PIPE Constants.DefinitionRow
)
BEGIN
    PATH &lt;DEF_INCR_CACHE_CONFIG_FOLDER&gt;;
    PATH /lib/resource;

    DECLARE PUBLIC IncrementalCacheRefreshException EXCEPTION;
 
    DECLARE PUBLIC LC_PERFORM_INCREMENTAL     CONSTANT BOOLEAN                   DEFAULT &lt;DEF_PERFORM_INCREMENTAL&gt;;
    DECLARE PUBLIC LC_HAS_PARTITION           CONSTANT BOOLEAN                   DEFAULT &lt;DEF_HAS_PARTITION&gt;;
    DECLARE PUBLIC LC_PARTITION_PERIOD_MONTHS CONSTANT INTEGER                   DEFAULT &lt;DEF_PARTITION_PERIOD_MONTHS&gt;;
    DECLARE PUBLIC LC_CACHED_VIEW             CONSTANT ResourceDefs.ResourcePath DEFAULT &apos;&apos;&lt;DEF_CACHED_VIEW_PATH&gt;&apos;&apos;;
    DECLARE PUBLIC LC_LIVE_VIEW               CONSTANT ResourceDefs.ResourcePath DEFAULT &apos;&apos;&lt;DEF_LIVE_VIEW_PATH&gt;&apos;&apos;;
    DECLARE PUBLIC LC_UNION_VIEW              CONSTANT ResourceDefs.ResourcePath DEFAULT &apos;&apos;&lt;DEF_UNION_VIEW_PATH&gt;&apos;&apos;;
 
    INSERT INTO result VALUES(
        CASE LC_PERFORM_INCREMENTAL WHEN TRUE THEN &apos;&apos;TRUE&apos;&apos; ELSE &apos;&apos;FALSE&apos;&apos; END,
        CASE LC_HAS_PARTITION WHEN TRUE THEN &apos;&apos;TRUE&apos;&apos; ELSE &apos;&apos;FALSE&apos;&apos; END,
        LC_PARTITION_PERIOD_MONTHS,
        LC_CACHED_VIEW,
        LC_LIVE_VIEW,
        LC_UNION_VIEW
    );
END&apos;;

    DECLARE PUBLIC FULL_CACHE_REFRESH_TEMPLATE CONSTANT VECTOR(System.Text) DEFAULT VECTOR[
-- INCR_TYPE_NONE
--
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
*/
PROCEDURE fullCacheRefresh(OUT IncrementalMaintenanceLevel VARCHAR)
BEGIN
    PATH &lt;DEF_CONFIG_FOLDER&gt;;
    PATH &lt;DEF_INCR_CACHE_PARENT_FOLDER&gt;/Common/support;
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;

    -- This script should never be called.
    --
    CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos; - Full cache refresh script of incremental cache solution called for resource &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;!&apos;&apos;);

END&apos;,

-- INCR_TYPE_LAST_UPDATED
--
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
*/
PROCEDURE fullCacheRefresh(OUT IncrementalMaintenanceLevel VARCHAR)
BEGIN
    PATH &lt;DEF_CONFIG_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;/support;
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;

    DECLARE PROC_NAME CONSTANT VARCHAR DEFAULT &apos;&apos;fullCacheRefresh&apos;&apos;;
    DECLARE NL CONSTANT CHAR(1) DEFAULT &apos;&apos;
&apos;&apos;;

	DECLARE cacheKey BIGINT;
	DECLARE maxLU TIMESTAMP;

	-- Retrieve cache key from request environment
    --
	CALL GetEnvironment(&apos;&apos;System.CACHED_RESOURCE_CACHE_KEY&apos;&apos;, cacheKey);

    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Beginning full refresh of &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - cache key = &apos;&apos; || cacheKey);

	-- Load cache target table
    --
	INSERT INTO
		&lt;DEF_CACHE_TABLE_PATH&gt;
	SELECT {option disable_data_cache}
		cacheKey, S.* 
	FROM
		&lt;DEF_CACHED_VIEW_PATH&gt; S;

	-- Determine initial snapshot level from cached data
    --
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Full refresh complete. Obtaining max last updated date from cached data ...&apos;&apos;);

	SELECT MAX(&lt;DEF_LAST_UPDATED_COLUMN_LIST&gt;) INTO maxLU FROM &lt;DEF_CACHE_TABLE_PATH&gt; C WHERE C.&lt;DEF_CACHEKEY_COLUMN&gt; = cacheKey;
	SET maxLU = COALESCE(maxLU, TIMESTAMP &apos;&apos;0001-01-01 00:00:00&apos;&apos;);

    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Setting initial last updated date to &apos;&apos; || maxLU);
 
	-- Return incremental maintenance level
    --
	SET IncrementalMaintenanceLevel = CAST(maxLU AS VARCHAR);
END&apos;,

-- INCR_TYPE_DELTA
--
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
*/
PROCEDURE fullCacheRefresh(OUT IncrementalMaintenanceLevel VARCHAR)
BEGIN
    PATH &lt;DEF_CONFIG_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;/support;
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;

    DECLARE PROC_NAME CONSTANT VARCHAR DEFAULT &apos;&apos;fullCacheRefresh&apos;&apos;;
    DECLARE NL CONSTANT CHAR(1) DEFAULT &apos;&apos;
&apos;&apos;;

	DECLARE cacheKey BIGINT;
	DECLARE maxLU TIMESTAMP;

	-- Retrieve cache key from request environment
    --
	CALL GetEnvironment(&apos;&apos;System.CACHED_RESOURCE_CACHE_KEY&apos;&apos;, cacheKey);

    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Beginning full refresh of &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - cache key = &apos;&apos; || cacheKey);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - initial maintenance level = &apos;&apos; || maxLU);
 
	-- Load cache target table
    --
	INSERT INTO
		&lt;DEF_CACHE_TABLE_PATH&gt;
	SELECT {option disable_data_cache}
		cacheKey, S.* 
	FROM
		&lt;DEF_CACHED_VIEW_PATH&gt; S;

	-- Determine initial snapshot level from cached data
    --
	SELECT MAX(&lt;DEF_LAST_UPDATED_COLUMN_LIST&gt;) INTO maxLU FROM &lt;DEF_CACHE_TABLE_PATH&gt; C WHERE C.&lt;DEF_CACHEKEY_COLUMN&gt; = cacheKey;
	SET maxLU = COALESCE(maxLU, TIMESTAMP &apos;&apos;0001-01-01 00:00:00&apos;&apos;);

    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Setting initial last updated date to &apos;&apos; || maxLU);
 
	-- Return incremental maintenance level
    --
	SET IncrementalMaintenanceLevel = CAST(maxLU AS VARCHAR);
END&apos;
];

    -- this VECTOR contains the templates for the various incremental collection procedures.
    -- as new incremental collection methods are needed, their templates can be added here.
    --
    DECLARE PUBLIC COLLECT_INCREMENT_TEMPLATE CONSTANT VECTOR(System.Text) DEFAULT VECTOR[
-- INCR_TYPE_NONE
--
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
**
** Increment collection type: None
*/
PROCEDURE collectIncrement (
    IN inCacheKey BIGINT,
    IN inMaxLastUpdated TIMESTAMP,
    OUT outRowsProcessed INTEGER,
    OUT outMaxLastUpdated VARCHAR
)
proc:
BEGIN
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;
 
/*
** Shouldn&apos;&apos;t be getting called. Nothing to do.
*/
 
    SET outRowsProcessed = -1;
    SET outMaxLastUpdated = NULL;
END&apos;,
 
-- INCR_TYPE_LAST_UPDATED
--
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
**
** Increment collection type: Last Updated
*/
PROCEDURE collectIncrement (
    IN inCacheKey BIGINT,
    IN inMaxLastUpdated TIMESTAMP,
    OUT outRowsProcessed INTEGER,
    OUT outMaxLastUpdated VARCHAR
)
proc:
BEGIN
    PATH &lt;DEF_CONFIG_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;/support;
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;
 
    DECLARE PROC_NAME CONSTANT VARCHAR DEFAULT &apos;&apos;collectIncrement&apos;&apos;;
    DECLARE NL CONSTANT CHAR(1) DEFAULT &apos;&apos;
&apos;&apos;;

    DECLARE l_serverId System.PropertyValue;
    DECLARE pqResult INTEGER;
    DECLARE l_cachePartitionDate TIMESTAMP;            -- partition date
    DECLARE i INTEGER DEFAULT 0;
    DECLARE countCurs CURSOR (myCount INTEGER);
    
&lt;DEF_PART_COMMENT_OPEN&gt;
    -- get the current partition date
    --
    SET l_cachePartitionDate = monthStartTimestampNMonthsAgo(Definitions.LC_PARTITION_PERIOD_MONTHS);
&lt;DEF_PART_COMMENT_CLOSE&gt;
 
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Beginning collection of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Collection method: Last updated&apos;&apos;);
 
    BEGIN INDEPENDENT TRANSACTION
 
        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Will check for new or existing rows with &lt;DEF_LAST_UPDATED_COLUMN_LIST&gt; &gt; &apos;&apos; || inMaxLastUpdated);
&lt;DEF_PART_SL_COMMENT&gt;        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Partitioning enabled: Limiting to rows with &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &gt;= &apos;&apos; || l_cachePartitionDate);
 
        -- clean out any existing data in the staging table
        --
        SELECT
            MYRESULT
        INTO
            pqResult
        FROM 
            &lt;DEF_TRUNCATE_TABLE_PROC&gt;(
                &apos;&apos;&lt;DEF_STAGE_TABLE_NAME&gt;&apos;&apos;
            );

        -- This query identifies new/updated records created since the last refresh
        -- and inserts them into a staging table in the cache database. Relies on initial full
        -- refresh being completed. Should catch any new records not in the cache that
        -- are within the partition period.
        --
        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Collecting new/updated rows.&apos;&apos;);
        INSERT INTO &lt;DEF_STAGE_TABLE_PATH&gt;
            SELECT {option DISABLE_DATA_CACHE}
                Constants.IU_CACHE_KEY &quot;cachekey&quot;,
&lt;DEF_SELECT_ALL_COLS&gt;
            FROM
                &lt;DEF_CACHED_VIEW_PATH&gt; incr_src
            WHERE 
&lt;DEF_PART_SL_COMMENT&gt;                incr_src.&quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &gt; l_cachePartitionDate AND
                &lt;DEF_LAST_UPDATED_COLUMN_LIST&gt; &gt; inMaxLastUpdated;
 
&lt;DEF_PART_COMMENT_OPEN&gt;
        -- This query identifies records that fall out of the cache partition date range
        -- and need to be removed from the cache table. these are also inserted into the
        -- staging table
        --
        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Collecting rows to be deleted that now fall outside the partition boundary.&apos;&apos;);
        INSERT INTO &lt;DEF_STAGE_TABLE_PATH&gt; (
            &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_INSERT_PK_COLS&gt;
            &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot;
        )
            SELECT 
                Constants.D_CACHE_KEY &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_SELECT1_PK_COLS&gt;
                c.&quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot;
            FROM      
                &lt;DEF_CACHE_TABLE_PATH&gt; c
            WHERE
                c.&quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &lt; l_cachePartitionDate AND
                c.&quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot; = inCacheKey;
&lt;DEF_PART_COMMENT_CLOSE&gt;
  
&lt;DEF_DEL_TABLE_COMMENT_OPEN&gt;
        -- This query identifies records that have been deleted from the data table
        -- and need to be removed from the cache table.
        --
        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Collecting rows to be deleted that appear in the deleted rows table.&apos;&apos;);
        INSERT INTO &lt;DEF_STAGE_TABLE_PATH&gt; (
            &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_INSERT_PK_COLS&gt;
            &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot;
        )
            SELECT
                Constants.D_CACHE_KEY &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_SELECT3_PK_COLS&gt;
                dr.&quot;&lt;DEF_DELETED_ACTIVITY_DATE_COLUMN&gt;&quot;
            FROM
                (SELECT
&lt;DEF_SELECT2_PK_COLS&gt;
                    d.&quot;&lt;DEF_DELETED_ACTIVITY_DATE_COLUMN&gt;&quot;,
                    MAX(d.&quot;&lt;DEF_DELETED_DATE_COLUMN&gt;&quot;) DELETED_DATE
                FROM
                    &lt;DEF_DELETED_TABLE_PATH&gt; d 
                WHERE
                    d.&quot;&lt;DEF_DELETED_DATE_COLUMN&gt;&quot; &gt;= inMaxLastUpdated AND
                    d.&quot;&lt;DEF_DELETED_ACTIVITY_DATE_COLUMN&gt;&quot; &gt;= l_cachePartitionDate
                GROUP BY
&lt;DEF_SELECT2_PK_COLS&gt;    
                    d.&quot;&lt;DEF_DELETED_ACTIVITY_DATE_COLUMN&gt;&quot;
            ) dr;
&lt;DEF_DEL_TABLE_COMMENT_CLOSE&gt;

        -- should only be one row here, but just in case there aren&apos;&apos;t any rows at all we use the FOR loop construct
        --
        FOR r AS
            SELECT
                MAX(&lt;DEF_LAST_UPDATED_COLUMN_LIST&gt;) maxLU,
                COUNT(*) rowCount
            FROM
                &lt;DEF_STAGE_TABLE_PATH&gt;
        DO
            SET outMaxLastUpdated = CAST(r.maxLU AS VARCHAR);
            SET outRowsProcessed = r.rowCount;
        END FOR;
        SET outMaxLastUpdated = COALESCE(outMaxLastUpdated, CAST(inMaxLastUpdated AS VARCHAR)); -- if no rows updated, set new max last updated to the previous value.
        SET outRowsProcessed = COALESCE(outRowsProcessed, 0);

    EXCEPTION
        ELSE
            CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos; - EXCEPTION&apos;&apos;);
            CALL icLog(Constants.DEBUG_LEVEL_ERROR, &apos;&apos;Error text: &apos;&apos; || CURRENT_EXCEPTION.TRACE);
 
            RAISE;
 
    END; -- INDEPENDENT TRANSACTION
 
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Total rows identified: &apos;&apos; || outRowsProcessed);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - New max LAST_UPDATED: &apos;&apos; || outMaxLastUpdated);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Completed collection of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
 
    LEAVE proc;
 
EXCEPTION
    ELSE
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos; - Collection of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot; FAILED at &apos;&apos; || CURRENT_TIMESTAMP());
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, &apos;&apos;Error text: &apos;&apos; || CURRENT_EXCEPTION.TRACE);

        RAISE;
END&apos;,
 
-- INCR_TYPE_DELTA
--
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
**
** Increment collection type: Delta
*/
PROCEDURE collectIncrement (
    IN inCacheKey BIGINT,
    IN inMaxLastUpdated TIMESTAMP,
    OUT outRowsProcessed INTEGER,
    OUT outMaxLastUpdated VARCHAR
)
proc:
BEGIN
    PATH &lt;DEF_CONFIG_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;/support;
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;
 
    DECLARE PROC_NAME CONSTANT VARCHAR DEFAULT &apos;&apos;collectIncrement&apos;&apos;;
    DECLARE NL CONSTANT CHAR(1) DEFAULT &apos;&apos;
&apos;&apos;;

    DECLARE l_serverId System.PropertyValue;
    DECLARE pqResult INTEGER;
    DECLARE l_cachePartitionDate TIMESTAMP;            -- partition date
    DECLARE i INTEGER DEFAULT 0;
    DECLARE countCurs CURSOR (myCount INTEGER);
    
    CALL PRINT(procName || &apos;&apos; - Starting Incremental refresh of &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
 
/*
** Retrieve the CIS server id.  We will need this as a filter when
** we access the cache_status table
*/
    CALL GetProperty(System.SERVER_ID, l_serverId);
    
&lt;DEF_PART_COMMENT_OPEN&gt;
    -- get the current partition date
    --
    SET l_cachePartitionDate = monthStartTimestampNMonthsAgo(Definitions.LC_PARTITION_PERIOD_MONTHS);
&lt;DEF_PART_COMMENT_CLOSE&gt;
 
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Beginning collection of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Collection method: Delta table&apos;&apos;);
 
    BEGIN INDEPENDENT TRANSACTION
 
        CALL LOG(PROC_NAME || &apos;&apos; - Will check for new or existing rows with &lt;DEF_LAST_UPDATED_COLUMN_LIST&gt; &gt; &apos;&apos; || inMaxLastUpdated);
&lt;DEF_PART_SL_COMMENT&gt;        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Partitioning enabled: Limiting to rows with &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &gt;= &apos;&apos; || l_cachePartitionDate);
  
        -- clean out any existing data in the staging table
        --
        SELECT
            MYRESULT
        INTO
            pqResult
        FROM 
            &lt;DEF_TRUNCATE_TABLE_PROC&gt;(
                &apos;&apos;&lt;DEF_STAGE_TABLE_NAME&gt;&apos;&apos;
            );
  
        -- This query identifies new records created since the last refresh
        -- and inserts them into a staging table in the cache database. Relies on initial full
        -- refresh being completed. Should catch any new records not in the cache that
        -- are within the partition period.
        --
        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Collecting new/updated rows.&apos;&apos;);
        INSERT INTO &lt;DEF_STAGE_TABLE_PATH&gt;
            SELECT {option DISABLE_DATA_CACHE}
                CASE (incr_src.&quot;&lt;DEF_DELTA_OPERATION_COLUMN&gt;&quot;)
                    WHEN &apos;&apos;&lt;DEF_DELTA_DELETE_OPERATION&gt;&apos;&apos; THEN Constants.D_CACHE_KEY
                    ELSE Constants.IU_CACHE_KEY
                END &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_SELECT_ALL_COLS&gt;
            FROM
                &lt;DEF_DELTA_VIEW_PATH&gt; incr_src
            WHERE 
&lt;DEF_PART_SL_COMMENT&gt;                incr_src.&quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &gt; l_cachePartitionDate AND
                &lt;DEF_LAST_UPDATED_COLUMN_LIST&gt; &gt; inMaxLastUpdated;
 
&lt;DEF_PART_COMMENT_OPEN&gt;
        -- This query identifies records that fall out of the cache partition date range
        -- and need to be removed from the cache table. these are also inserted into the
        -- staging table
        --
        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Collecting rows to be deleted that now fall outside the partition boundary.&apos;&apos;);
        INSERT INTO &lt;DEF_STAGE_TABLE_PATH&gt; (
            &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_INSERT_PK_COLS&gt;
            &quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot;
        )
            SELECT 
                Constants.D_CACHE_KEY &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_SELECT1_PK_COLS&gt;
                c.&quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot;
            FROM      
                &lt;DEF_CACHE_TABLE_PATH&gt; c
            WHERE
                c.&quot;&lt;DEF_ACTIVITY_DATE_COLUMN&gt;&quot; &lt; l_cachePartitionDate AND
                c.&quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot; = inCacheKey;
&lt;DEF_PART_COMMENT_CLOSE&gt;
   
        -- should only be one row here, but just in case there aren&apos;&apos;t any rows at all we use the for loop construct
        --
        FOR r AS
            SELECT
                MAX(&lt;DEF_LAST_UPDATED_COLUMN_LIST&gt;) maxLU,
                COUNT(*) rowCount
            FROM
                &lt;DEF_STAGE_TABLE_PATH&gt;
        DO
            SET outMaxLastUpdated = CAST(r.maxLU AS VARCHAR);
            SET outRowsProcessed = r.rowCount;
        END FOR;
        SET outMaxLastUpdated = COALESCE(outMaxLastUpdated, CAST(inMaxLastUpdated AS VARCHAR)); -- if no rows updated, set new max last updated to the previous value.
        SET outRowsProcessed = COALESCE(outRowsProcessed, 0);

    EXCEPTION
        ELSE
            CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos; - EXCEPTION&apos;&apos;);
            CALL icLog(Constants.DEBUG_LEVEL_ERROR, &apos;&apos;Error text: &apos;&apos; || CURRENT_EXCEPTION.TRACE);

            RAISE;
 
    END; -- INDEPENDENT TRANSACTION
 
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Total rows identified: &apos;&apos; || outRowsProcessed);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - New max LAST_UPDATED: &apos;&apos; || outMaxLastUpdated);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Completed collection of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
 
    LEAVE proc;
 
EXCEPTION
    ELSE
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos; - Collection of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot; FAILED at &apos;&apos; || CURRENT_TIMESTAMP());
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, &apos;&apos;Error text: &apos;&apos; || CURRENT_EXCEPTION.TRACE);

        RAISE;
END&apos;
    ];
 
    DECLARE PUBLIC APPLY_INCREMENT_TEMPLATES CONSTANT VECTOR(System.Text) DEFAULT VECTOR [
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
*/
PROCEDURE applyIncrement(
    IN inCacheKey BIGINT
)
proc:
BEGIN 
    PATH &lt;DEF_CONFIG_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;/support;
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;
 
    DECLARE PROC_NAME CONSTANT VARCHAR DEFAULT &apos;&apos;applyIncrement&apos;&apos;;
    DECLARE NL CONSTANT CHAR(1) DEFAULT &apos;&apos;
&apos;&apos;;

    DECLARE resourceExists BOOLEAN;
    DECLARE pqText LONGVARCHAR;
    DECLARE pqResult INTEGER;
    DECLARE l_success BIT;
 
    DECLARE cacheSelectList System.Text DEFAULT
&apos;&apos;    &quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_SEL_COLUMNS&gt;
&apos;&apos;;

    DECLARE joinCriteria System.Text DEFAULT
&apos;&apos;&lt;DEF_JOIN_COND&gt;&apos;&apos;;

    DECLARE cacheUpdateList System.Text DEFAULT
&apos;&apos;&lt;DEF_UPD_LIST&gt;&apos;&apos;;

    DECLARE cacheInsertColList System.Text DEFAULT
&apos;&apos;    c.&quot;&lt;DEF_CACHEKEY_COLUMN&gt;&quot;,
&lt;DEF_INS_COLUMNS&gt;
&apos;&apos;;

    DECLARE cacheInsertValueList System.Text DEFAULT
&apos;&apos;    &apos;&apos; || inCacheKey || &apos;&apos;,
&lt;DEF_INS_VALUES&gt;
&apos;&apos;;

    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Starting application of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - cacheKey: &apos;&apos; || inCacheKey);
    CALL debugPQOracleApplyIncrUpdates(
        &apos;&apos;&lt;DEF_CACHE_TABLE_NAME&gt;&apos;&apos;,
        cacheSelectList,
        &apos;&apos;&lt;DEF_STAGE_TABLE_NAME&gt;&apos;&apos;,
        &apos;&apos;&lt;DEF_CACHEKEY_COLUMN&gt;&apos;&apos;,
        joinCriteria,
        cacheUpdateList,
        Constants.D_CACHE_KEY,
        cacheInsertColList,
        cacheInsertValueList,
        pqText
    );
 
    SELECT
        MYRESULT
    INTO
        pqResult
    FROM 
        pq_Oracle_ApplyIncrUpdates(
            &apos;&apos;&lt;DEF_CACHE_TABLE_NAME&gt;&apos;&apos;,
            cacheSelectList,
            &apos;&apos;&lt;DEF_STAGE_TABLE_NAME&gt;&apos;&apos;,
            &apos;&apos;&lt;DEF_CACHEKEY_COLUMN&gt;&apos;&apos;,
            joinCriteria,
            cacheUpdateList,
            Constants.D_CACHE_KEY,
            cacheInsertColList,
            cacheInsertValueList
        );

    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Completed application of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
 
    LEAVE proc;
EXCEPTION
    ELSE
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos; - Collection of incremental refresh data for &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot; FAILED at &apos;&apos; || CURRENT_TIMESTAMP());
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos;: &apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;: Rolling back incremental refresh.&apos;&apos;);
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, &apos;&apos;Error text: &apos;&apos; || CURRENT_EXCEPTION.TRACE);

        RAISE;
END
&apos;
];
 
    DECLARE PUBLIC INCREMENTAL_REFRESH_TEMPLATE CONSTANT System.Text DEFAULT
&apos;/*
** Automatically generated with &lt;DEF_PROC&gt; 
** by &lt;DEF_USERID&gt; 
** on &lt;DEF_CURRENT_TIMESTAMP&gt;
*/
PROCEDURE incrementalRefresh(
    OUT outMaxLastUpdated VARCHAR
)
proc:
BEGIN
    PATH &lt;DEF_CONFIG_FOLDER&gt;;
    PATH &lt;DEF_CONFIG_FOLDER&gt;/support;
    PATH &lt;DEF_COMMON_FOLDER&gt;;
    PATH &lt;DEF_COMMON_FOLDER&gt;/support;
    PATH &lt;DEF_INCR_CACHE_FOLDER&gt;;
    PATH /lib/resource;
 
    DECLARE PROC_NAME CONSTANT VARCHAR DEFAULT &apos;&apos;incrementalRefresh&apos;&apos;;
    DECLARE NL CONSTANT CHAR(1) DEFAULT &apos;&apos;
&apos;&apos;;

    DECLARE resultCode INTEGER;
    DECLARE resultMessage VARCHAR(65536);

	DECLARE l_cacheKey BIGINT;
	DECLARE l_maxLastUpdated TIMESTAMP;

    DECLARE l_refreshStart TIMESTAMP DEFAULT CURRENT_TIMESTAMP();
    DECLARE l_updatePartitionStatus BIT;
    DECLARE l_updatePartitionMessage VARCHAR(65536);
    DECLARE l_resourceName ResourceDefs.ResourceName DEFAULT basename (Definitions.LC_CACHED_VIEW);
    DECLARE l_resourceContainer ResourceDefs.ResourcePath DEFAULT dirname (Definitions.LC_CACHED_VIEW);
    DECLARE l_storageUsed BIGINT;
    DECLARE l_cacheKeyVal BIGINT;
    DECLARE l_resourceExists BOOLEAN;
    DECLARE l_success BIT;
    DECLARE l_maxLastUpdatedFound BOOLEAN DEFAULT FALSE;
    DECLARE l_refreshDuration DOUBLE DEFAULT 0;
    DECLARE l_numRowsProcessed BIGINT DEFAULT 0;
    DECLARE i INTEGER;
    DECLARE l_dstatus CHAR(1);
    DECLARE l_verifyResultCode INTEGER;
    DECLARE l_verifyResultMessage VARCHAR(65536);
 
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Incremental cache refresh of &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot; STARTED&apos;&apos;);
 
/*
** Retrieve the cache key and previous cache refresh&apos;&apos;s last updated date.
*/
	CALL GetEnvironment(&apos;&apos;System.CACHED_RESOURCE_CACHE_KEY&apos;&apos;, l_cacheKey);
	CALL GetEnvironment(&apos;&apos;System.CACHED_RESOURCE_INCREMENTAL_MAINTENANCE_LEVEL&apos;&apos;, l_maxLastUpdated);
    
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - cacheKey: &apos;&apos; || l_cacheKey);
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - previous max LAST_UPDATED: &apos;&apos; || l_maxLastUpdated);
 
/*
** if partitioning is enabled then reset the partition dates in the partition views.
*/
    IF (Definitions.LC_HAS_PARTITION) THEN
        CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - updating partition date of union view &quot;&apos;&apos; || Definitions.LC_UNION_VIEW || &apos;&apos;&quot;&apos;&apos;);

        CALL updatePartitionDate (
            monthStartTimestampNMonthsAgo(Definitions.LC_PARTITION_PERIOD_MONTHS),
            Definitions.LC_CACHED_VIEW,
            Definitions.LC_LIVE_VIEW,
            Definitions.LC_UNION_VIEW,
            l_updatePartitionStatus,
            l_updatePartitionMessage
        );
 
        IF (l_updatePartitionStatus &lt;&gt; 1) THEN
            RAISE System.IllegalStateException VALUE &apos;&apos;Unable to update the partition date of the partitioning views: &apos;&apos; || l_updatePartitionMessage;
        END IF;
    END IF;
 
	-- make sure the staging table exists. (if this script was deployed
	-- to another environment, it&apos;&apos;s possible the staging table wasn&apos;&apos;t created
	-- for it.) This is only possible when when the Configuration Panel setting
    -- Server/Configuration/Security/&quot;Enable Task Session API Access&quot; is enabled
    -- (disabled by default.)
	--
/*
    BEGIN INDEPENDENT TRANSACTION

		CALL ResourceExists(
			&apos;&apos;&lt;DEF_STAGE_TABLE_PATH&gt;&apos;&apos;,
			&apos;&apos;TABLE&apos;&apos;,
			NULL,
			l_resourceExists
		);
	
		IF (NOT l_resourceExists) THEN
            CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos;: Staging table &quot;&lt;DEF_STAGE_TABLE_PATH&gt;&quot; missing. Rebuilding.&apos;&apos;);

			CALL &lt;DEF_CREATE_TABLE_AS_PROC&gt;(
				&lt;DEF_CACHE_CATALOG&gt;,
				&lt;DEF_CACHE_SCHEMA&gt;,
				&apos;&apos;&lt;DEF_STAGE_TABLE_NAME&gt;&apos;&apos;,
				&apos;&apos;&lt;DEF_CACHE_TABLE_NAME&gt;&apos;&apos;,
				&apos;&apos;&lt;DEF_CACHE_DS&gt;&apos;&apos;,
				l_success
			);
		END IF;

        COMMIT;
    END; -- independent transaction 
*/
    -- if the staging table was missing at the time this script started,
    -- this transaction block will allow collectIncrement() to see the
    -- staging table created above.
    --
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos;: beginning collection phase - &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
    BEGIN INDEPENDENT TRANSACTION
		CALL collectIncrement(
            l_cacheKey,
            l_maxLastUpdated,
            l_numRowsProcessed,
            outMaxLastUpdated
        );
    END;

    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos;: beginning application phase - &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot;&apos;&apos;);
    CALL applyIncrement(l_cacheKey);

    -- gather some statistics about the refresh
    --
    SET l_refreshDuration = intervalDay2Seconds(CURRENT_TIMESTAMP - l_refreshStart);

    -- set exit messaging
    --
    CALL icLog(Constants.DEBUG_LEVEL_DEBUG, PROC_NAME || &apos;&apos; - Incremental cache refresh of &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot; SUCCEEDED. &apos;&apos; || 
         COALESCE(l_numRowsProcessed, 0) || &apos;&apos; total rows processed in &apos;&apos; || l_refreshDuration || &apos;&apos; seconds&apos;&apos;);

    SET resultCode = 0;
    SET resultMessage = &apos;&apos;Incremental cache refresh of &apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos; SUCCEEDED. &apos;&apos; || 
                        COALESCE(l_numRowsProcessed, 0) || &apos;&apos; total rows processed in &apos;&apos; || l_refreshDuration || &apos;&apos; seconds&apos;&apos;;
 
EXCEPTION
    ELSE
        CALL icLog(Constants.DEBUG_LEVEL_ERROR, PROC_NAME || &apos;&apos;: &quot;&apos;&apos; || Definitions.LC_CACHED_VIEW || &apos;&apos;&quot; - REFRESH ERROR! &apos;&apos; || NL || &apos;&apos;Error text: &apos;&apos; || CURRENT_EXCEPTION.TRACE);

        RAISE; 
END&apos;;

END

</attribute>
  <attribute name="creationDate" type="LONG">0</attribute>
  <attribute name="creatorUserDomain" type="STRING"/>
  <attribute name="creatorUserName" type="STRING"/>
  <attribute name="explicitly.designed" type="BOOLEAN">false</attribute>
  <attribute name="impactLevel" type="INTEGER">0</attribute>
  <attribute name="impactMessage" type="NULL"/>
  <attribute name="lastModifiedDate" type="LONG">1399939771794</attribute>
  <attribute name="lastModifiedUserDomain" type="STRING">composite</attribute>
  <attribute name="lastModifiedUserName" type="STRING">admin</attribute>
  <attribute name="model" type="NULL"/>
  <attribute name="native_only" type="STRING">false</attribute>
  <attribute name="public_constants" type="MAP">
    <item>
      <key type="STRING">PART_CACHED_VIEW_TEMPLATE</key>
      <value type="BYTE_ARRAY">EBsGAgAEAEMASABBAFIDEgAAAAEBOwAEBQAAAAAAAADoBAQAAAAAAAAA6AETAf//</value>
    </item>
    <item>
      <key type="STRING">INCREMENTAL_REFRESH_TEMPLATE</key>
      <value type="BYTE_ARRAY">EBsGAgAEAEMASABBAFIDEgAAAAEBOwAEBQAAAAAAABTPBAQAAAAAAAAUzwETAf//</value>
    </item>
    <item>
      <key type="STRING">DEFINITIONS_TEMPLATE</key>
      <value type="BYTE_ARRAY">EBsGAgAEAEMASABBAFIDEgAAAAEBOwAEBQAAAAAAAAUHBAQAAAAAAAAFBwETAf//</value>
    </item>
    <item>
      <key type="STRING">PART_UNION_VIEW_TEMPLATE</key>
      <value type="BYTE_ARRAY">EBsGAgAEAEMASABBAFIDEgAAAAEBOwAEBQAAAAAAAAKxBAQAAAAAAAACsQETAf//</value>
    </item>
    <item>
      <key type="STRING">FULL_CACHE_REFRESH_TEMPLATE</key>
      <value type="BYTE_ARRAY">ECMGAgAbAEYAVQBMAEwAXwBDAEEAQwBIAEUAXwBSAEUARgBSAEUAUwBIAF8AVABFAE0AUABMAEEA
VABFAxIAAAABBAQAAAAAAAAAAAgZEBsGAgAEAEMASABBAFIDEgAAAAIBOwAEBQAAAAAAAAIRBAQA
AAAAAAAGGwETAf////8=</value>
    </item>
    <item>
      <key type="STRING">PART_LIVE_VIEW_TEMPLATE</key>
      <value type="BYTE_ARRAY">EBsGAgAEAEMASABBAFIDEgAAAAEBOwAEBQAAAAAAAADnBAQAAAAAAAAA5wETAf//</value>
    </item>
    <item>
      <key type="STRING">COLLECT_INCREMENT_TEMPLATE</key>
      <value type="BYTE_ARRAY">ECMGAgAaAEMATwBMAEwARQBDAFQAXwBJAE4AQwBSAEUATQBFAE4AVABfAFQARQBNAFAATABBAFQA
RQMSAAAAAQQEAAAAAAAAAAAIGRAbBgIABABDAEgAQQBSAxIAAAACATsABAUAAAAAAAAB1QQEAAAA
AAAAGYkBEwH/////</value>
    </item>
    <item>
      <key type="STRING">APPLY_INCREMENT_TEMPLATES</key>
      <value type="BYTE_ARRAY">ECMGAgAZAEEAUABQAEwAWQBfAEkATgBDAFIARQBNAEUATgBUAF8AVABFAE0AUABMAEEAVABFAFMD
EgAAAAEEBAAAAAAAAAAACBkQGwYCAAQAQwBIAEEAUgMSAAAAAgE7AAQFAAAAAAAAChkEBAAAAAAA
AAoZARMB/////w==</value>
    </item>
  </attribute>
  <attribute name="references" type="MAP">
    <item>
      <key type="STRING">64/100</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
    <item>
      <key type="STRING">62/559</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
    <item>
      <key type="STRING">50/68</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
    <item>
      <key type="STRING">55/16</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
    <item>
      <key type="STRING">53/29</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
    <item>
      <key type="STRING">54/42</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
    <item>
      <key type="STRING">63/223</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
    <item>
      <key type="STRING">58/651</key>
      <value type="STRING_ARRAY">
        <item>lib</item>
        <item>util</item>
        <item>System</item>
      </value>
    </item>
  </attribute>
</metadata>